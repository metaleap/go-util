package udevps

/*
Represents everything in coreimp.json files
generated by purs with the --dump-coreimp option.

In here we mostly deal with the stuff in Body
(the actual JS-like core-imperative AST ie funcs + vars),
whereas DeclAnns and DeclEnv (PureScript types &
signatures) are mostly handled in ps-coreimp-decls.go.
*/

type CoreImp struct { // we skip unmarshaling what isn't used for now, but DO keep these around commented-out:
	// BuiltWith  string            `json:"builtWith"`
	// ModuleName string            `json:"moduleName"`
	// ModulePath string            `json:"modulePath"`
	// Comments   []*CoreComment `json:"comments"`
	// Foreign    []string          `json:"foreign"`
	// Exports    []string          `json:"exports"`
	Imps     [][]string  `json:"imports"`
	Body     CoreImpAsts `json:"body"`
	DeclAnns []*CoreDecl `json:"declAnns"`
	DeclEnv  CoreEnv     `json:"declEnv"`

	My struct {
		ImpFilePath   string
		NamedRequires map[string]string
	}
}

func (me *CoreImp) Prep() {
	for _, da := range me.DeclAnns {
		da.prep()
	}
	me.DeclEnv.prep()
}

type CoreImpAsts []*CoreImpAst

type CoreImpAst struct {
	AstSourceSpan  *CoreSourceSpan `json:"sourceSpan"`
	AstTag         string          `json:"tag"`
	AstBody        *CoreImpAst     `json:"body"`
	AstRight       *CoreImpAst     `json:"rhs"`
	AstCommentDecl *CoreImpAst     `json:"decl"`
	AstApplArgs    CoreImpAsts     `json:"args"`
	AstOp          string          `json:"op"`
	AstFuncParams  []string        `json:"params"`
	AstFor1        *CoreImpAst     `json:"for1"`
	AstFor2        *CoreImpAst     `json:"for2"`
	AstThen        *CoreImpAst     `json:"then"`
	AstElse        *CoreImpAst     `json:"else"`

	Function             string
	StringLiteral        string
	BooleanLiteral       bool
	IntegerLiteral       int
	NumberLiteral        float64
	Block                CoreImpAsts
	Var                  string
	VariableIntroduction string
	While                *CoreImpAst
	App                  *CoreImpAst
	Unary                *CoreImpAst
	Comment              []*CoreComment
	Binary               *CoreImpAst
	ForIn                string
	For                  string
	IfElse               *CoreImpAst
	ObjectLiteral        []map[string]*CoreImpAst
	Return               *CoreImpAst
	Throw                *CoreImpAst
	ArrayLiteral         CoreImpAsts
	Assignment           *CoreImpAst
	Indexer              *CoreImpAst
	Accessor             *CoreImpAst
	InstanceOf           *CoreImpAst

	Parent *CoreImpAst
	Root   *CoreImp
}

func (me *CoreImp) InitAstOnLoaded() {
	me.Body = me.initSubAsts(nil, me.Body...)
}

func (me *CoreImp) PrepTopLevel() {
	me.My.NamedRequires = map[string]string{}
	i := 0
	ditch := func() {
		me.Body = append(me.Body[:i], me.Body[i+1:]...)
		i--
	}
	for i = 0; i < len(me.Body); i++ {
		a := me.Body[i]
		if a.StringLiteral == "use strict" {
			//	"use strict"
			ditch()
		} else if a.Assignment != nil && a.Assignment.Indexer != nil && a.Assignment.Indexer.Var == "module" && a.Assignment.AstRight != nil && a.Assignment.AstRight.StringLiteral == "exports" {
			//	module.exports = ..
			ditch()
		} else if a.AstTag == "VariableIntroduction" {
			if a.AstRight != nil && a.AstRight.App != nil && a.AstRight.App.Var == "require" && len(a.AstRight.AstApplArgs) == 1 && len(a.AstRight.AstApplArgs[0].StringLiteral) > 0 {
				me.My.NamedRequires[a.VariableIntroduction] = a.AstRight.AstApplArgs[0].StringLiteral
				ditch()
			} else if a.AstRight != nil && a.AstRight.AstTag == "Function" {
				// turn top-level `var foo = func()` into `func foo()`
				a.AstRight.Function = a.VariableIntroduction
				a = a.AstRight
				a.Parent, me.Body[i] = nil, a
			}
		} else if a.AstTag != "Function" && a.AstTag != "VariableIntroduction" && a.AstTag != "Comment" {
			panic(NotImplErr("top-level CoreImp AST tag", a.AstTag, me.My.ImpFilePath))
		}
	}
}

func (me *CoreImp) initSubAsts(Parent *CoreImpAst, asts ...*CoreImpAst) CoreImpAsts {
	if Parent != nil {
		Parent.Root = me
	}
	for ai, a := range asts {
		if a != nil {
			//	we might swap out `a` in here
			if a.AstTag == "Comment" && a.AstCommentDecl != nil {
				//	decls as sub-asts of comments is handy for PureScript but not for our own traversals, we lift the inner decl outward and set its own Comment instead. hence, we never process any AstCommentDecl, after this branch they're all nil
				if a.AstCommentDecl.AstTag == "Comment" {
					panic(NotImplErr("comments", "nesting", me.My.ImpFilePath))
				}
				decl := a.AstCommentDecl
				a.AstCommentDecl, decl.Comment, decl.Parent = nil, a.Comment, Parent
				a, asts[ai] = decl, decl
			}
			//	we might swap out `a` in here
			if Parent != nil && a.AstTag == "Function" && a.Function != "" {
				//	there are a handful of cases (TCO it looks like) where CoreImp function bodies contain inner "full" functions as top-level-style stand-alone defs instead of bound expressions --- we bind them to a var right here, early on.
				nuvar := &CoreImpAst{AstTag: "VariableIntroduction", VariableIntroduction: a.Function, AstRight: a, Parent: Parent}
				a.Parent, a.Function = nuvar, ""
				a, asts[ai] = nuvar, nuvar
			}
			//	we might swap out `a` in here
			if a.AstTag == "Unary" && a.AstOp == "Not" && a.Unary.AstTag == "BooleanLiteral" {
				operand := a.Unary
				operand.Parent, operand.BooleanLiteral = Parent, !a.Unary.BooleanLiteral
				a, asts[ai] = operand, operand
			}
			//	now proceed whatever `a` now is

			a.For = StrReplUnsanitize.Replace(a.For)
			a.ForIn = StrReplUnsanitize.Replace(a.ForIn)
			a.Function = StrReplUnsanitize.Replace(a.Function)
			a.Var = StrReplUnsanitize.Replace(a.Var)
			a.VariableIntroduction = StrReplUnsanitize.Replace(a.VariableIntroduction)

			for i, mkv := range a.ObjectLiteral {
				for onename, oneval := range mkv {
					if nuname := StrReplUnsanitize.Replace(onename); nuname != onename {
						mkv = map[string]*CoreImpAst{}
						mkv[nuname] = oneval
						a.ObjectLiteral[i] = mkv
					}
				}
			}
			for i, afp := range a.AstFuncParams {
				a.AstFuncParams[i] = StrReplUnsanitize.Replace(afp)
			}

			a.Root = me
			a.Parent = Parent
			a.App = me.initSubAsts(a, a.App)[0]
			a.ArrayLiteral = me.initSubAsts(a, a.ArrayLiteral...)
			a.Assignment = me.initSubAsts(a, a.Assignment)[0]
			a.AstApplArgs = me.initSubAsts(a, a.AstApplArgs...)
			a.AstBody = me.initSubAsts(a, a.AstBody)[0]
			a.AstCommentDecl = me.initSubAsts(a, a.AstCommentDecl)[0]
			a.AstFor1 = me.initSubAsts(a, a.AstFor1)[0]
			a.AstFor2 = me.initSubAsts(a, a.AstFor2)[0]
			a.AstElse = me.initSubAsts(a, a.AstElse)[0]
			a.AstThen = me.initSubAsts(a, a.AstThen)[0]
			a.AstRight = me.initSubAsts(a, a.AstRight)[0]
			a.Binary = me.initSubAsts(a, a.Binary)[0]
			a.Block = me.initSubAsts(a, a.Block...)
			a.IfElse = me.initSubAsts(a, a.IfElse)[0]
			a.Indexer = me.initSubAsts(a, a.Indexer)[0]
			a.Assignment = me.initSubAsts(a, a.Assignment)[0]
			a.InstanceOf = me.initSubAsts(a, a.InstanceOf)[0]
			a.Return = me.initSubAsts(a, a.Return)[0]
			a.Throw = me.initSubAsts(a, a.Throw)[0]
			a.Unary = me.initSubAsts(a, a.Unary)[0]
			a.While = me.initSubAsts(a, a.While)[0]
			for km, m := range a.ObjectLiteral {
				for kx, expr := range m {
					m[kx] = me.initSubAsts(a, expr)[0]
				}
				a.ObjectLiteral[km] = m
			}
		}
	}
	return asts
}
